{"meta":{"title":"尽莉了","subtitle":null,"description":"英莉莉赛高","author":"佑砢君","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-04-06T10:48:03.966Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[英梨々の佑砢君] 与&nbsp; 佑砢君&nbsp; （ 英梨々 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-04-04T12:24:54.598Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-04-06T09:50:21.296Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-04-06T10:27:46.954Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"蟹蟹大佬~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-04-06T09:56:50.362Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人たち"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-04-06T09:49:14.079Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"js 基础语法第 4 期","slug":"js学习4","date":"2020-09-22T12:05:46.000Z","updated":"2020-09-22T12:31:09.558Z","comments":true,"path":"2020/09/22/js学习4/","link":"","permalink":"/2020/09/22/js学习4/","excerpt":"","text":"前言这次的笔记是关于 js 的模块化技术，一共有两个文件，我将需要导入的测试米快都写在了 utils.js 中。 模块文件 utils.js//p105 模块化-导出模块 /** * * @param {Date} date */ export function formatDate(date) { return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`; } //p106导出多个条目 export const DAYS_OF_YEAR = 365; //想要在底部全部导出也可以把前面的erport全部删除 //然后在底部写erport{formatDate, DAYS_OF_YEAR} //p107 默认导出 //看视频 下面是 js 笔记//p105 模块化-导出模块 import { formatDate, DAYS_OF_YEAR } from &quot;./utils.js&quot;; console.log(formatDate(new Date())); //p106导出多个条目 console.clear(); console.log(DAYS_OF_YEAR); //vscode支持自动导入，会发现第二行代码的大括号里自动加了DAYS_OF_YEAR //p107 默认导出 console.clear(); //看视频 //p108 别名导入 import { DAYS_OF_YEAR as DAYS } from &quot;./utils.js&quot;; console.log(DAYS); //也可以导入整个文件然后取一个别名 import * as utils from &quot;./utils.js&quot;; console.log(utils.formatDate(new Date())); console.log(utils.DAYS_OF_YEAR); 总结所有的 js 笔记到这里就结束了，接下来的就是多加练习实际操作，掌握了基础就能向更多的方向去拓展，加油！","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"-悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"js 基础语法第 3 期","slug":"js学习3","date":"2020-09-22T11:40:21.000Z","updated":"2020-09-22T12:12:19.854Z","comments":true,"path":"2020/09/22/js学习3/","link":"","permalink":"/2020/09/22/js学习3/","excerpt":"","text":"前言从这期开始的代码都是 js 的新特性，只有部分新版本浏览器已经适配，在使用前请确保你的浏览器版本已经适配这些特性。 下面是代码//p70 成员变量(这之后的语法都是新语法只有部分浏览器支持) //成员变量知指的是类里面定义的变量 class Employee { dept = &quot;&quot;; constructor(name) { this.name = &quot;员工姓名&quot; + name; } } var emp = new Employee(&quot;佑砢&quot;); console.log(emp); emp.dept = &quot;技术部&quot;; console.log(emp); //p71 静态成员(限制作用域) console.clear(); class Page { static count = 0; static increaseViewCount() { Page.count++; } } Page.count++; console.log(Page.count); Page.increaseViewCount(); console.log(Page.count); //p72 字符串定义 console.clear(); var str = &quot;hello&quot;; console.log(str); var str2 = new String(&quot;你好&quot;); console.log(str2); //转义字符 str = &#39;他说：&quot;我们出去玩吧&quot;&#39;; //转义本身就两个反斜杠，\\n代表换行，\\t代表tab键 console.log(str); console.log(&quot;\\u1010&quot;); //符号 //p73 字符串遍历 console.clear(); for (let i = 0; i &lt; str.length; i++) { console.log(str.charAt(i)); } for (let c of str) { console.log(c); } //p74 字符串裁切 console.clear(); //slice接受两个参数。一个开始一个结束，结果会包含开始的参数的内容而不包含结束的参数的内容 var str = &quot;This is a long string......&quot;; console.log(str.slice(0, 4)); console.log(str.slice(4)); //从第4位一直到结尾 console.log(str.slice(0, -1)); console.log(str.slice(-6, -1)); console.log(str.slice(4, 1)); //开始大于结束默认返回空字符串 //substring console.log(str.substring(0, 4)); console.log(str.substring(4)); console.log(str.substring(0, -1)); //sunstring不能接受负数，如果接收负数，或者不是数字的类型会变成接收0 console.log(str.substring(-6, -1)); console.log(str.substring(4, 1)); //开始大于结束会把两个值替换 //p75 字符串拼接 console.clear(); var str1 = &quot;hello &quot;; var str2 = &quot;world!&quot;; console.log(str1 + str2); console.log(str1.concat(str2)); //p76 大小写转换 console.clear(); console.log(str1.toUpperCase()); console.log(&quot;WORLD&quot;.toLocaleLowerCase()); //p77 去除空格 console.clear(); var str = &quot; hello world &quot;; console.log(str.trim()); //能去除开头结尾空格不能去中间的空格 //p78 模板字符串 console.clear(); var longStr = `dsfdsa s fdsaf dsaf dsf sdaf sda dsg fdg gfhzb vhxfgh fxgh fgjxg jnfgxhf h fgh `; console.log(longStr); var name = &quot;佑砢&quot;; var str = `你好,${name}`; console.log(str); function greeting(strings, gender) { let genderStr = &quot;&quot;; if (gender === &quot;M&quot;) { genderStr = &quot;先生&quot;; } else if (gender === &quot;F&quot;) { genderStr = &quot;女士&quot;; } return `${strings[0]}${genderStr}`; } var gender = &quot;M&quot;; var result = greeting`你好，佑砢${gender}`; console.log(result); //p79 正则表达式-创建正则表达式 console.clear(); var str = &quot;where when what&quot;; var re = /wh/g; //g代表全局搜索，可以不加，那么只会匹配一次 var re2 = new RegExp(&quot;wh&quot;); console.log(re.exec(str)); console.log(re.exec(str)); //会返回匹配的内容 console.log(re.test(str)); //只会返回true，false，即有没有匹配到 console.log(re2.exec(str)); console.log(re2.test(str)); //p80 正则-字符匹配 console.clear(); var str = `This str contains 123 CAPITALIZED letter and _-&amp;^% symbols`; console.log(/T/.test(str)); console.log(/This/.test(str)); console.log(/Thiss/.test(str)); console.log(/12/.test(str)); console.log(/1234/.test(str)); console.log(/_-&amp;/.test(str)); //p80 特殊字符匹配 console.clear(); console.log(str.match(/Th.s/g)); console.log(str.match(/1.3/g)); console.log(str.match(/\\d/g)); console.log(str.match(/\\w/g)); console.log(str.match(/\\s/g)); console.log(&quot;你好&quot;.match(/\\u4f60/g)); //p81 匹配次数 console.clear(); var str = `This str contains 123 CAPITALIZED letter and _-&amp;^% symbols`; console.log(str.match(/This.*/g)); //多次匹配 console.log(str.match(/t+/g)); //匹配1次到多次，区分大小写的 console.log(str.match(/x?/g)); //匹配0或1次 console.log(str.match(/x?/g)); console.log(str.match(/t{2}/g)); //精确判断出现次数 console.log(str.match(/\\d{1,2}/g)); //出现1至2次 console.log(str.match(/\\d{1,}/g)); //至少出现1次 //p82 区间、逻辑和界定符 console.clear(); console.log(str.match(/[abc]/g)); console.log(str.match(/[a-z]/g)); //代表匹配26个小写字母 console.log(str.match(/[A-Z]/g)); //代表匹配26个大写字母 console.log(str.match(/[^0-9]/g)); //代表匹配非0-9区间内的字符 console.log(str.match(/[\\-_&amp;\\^]/g)); // \\用来转义 console.log(str.match(/This|contains/g)); var str = &quot;this that athisa and that&quot;; console.log(str.match(/^this/g)); //匹配开头的this console.log(str.match(/that$/g)); //匹配结尾的this console.log(str.match(/\\bthat\\b/g)); //表示只返回没有间隔的that //p83 分组 console.clear(); var str = `this that this and that`; console.log(/(th).*(th)/.exec(str)); //()内是要的数据 var str = `aaaab abb cddaa`; console.log(str.match(/(aa){2}/g)); //出现两次的aa //p84 常见正则表达式 console.clear(); var mobileRe = /^1[3-9]\\d{9}/g; console.log(mobileRe.test(&quot;138666666666&quot;)); var emailRe = /(^[a-zA-Z0-9_\\-\\.]+)@([a-z-A-Z0-9_\\-\\.]+\\.([a-zA-Z]{2,5}))$/g; console.log(emailRe.test(&quot;admin@163.com&quot;)); console.log(emailRe.test(&quot;admin@163.commmmmmmmmmm&quot;)); var usernameRe = /^[a-zA-Z][a-zA-Z0-9_]{5,14}/g; console.log(usernameRe.test(&quot;abc&quot;)); console.log(usernameRe.test(&quot;$aaa&quot;)); console.log(usernameRe.test(&quot;abcaaaaaaaa_aa&quot;)); //p85 字符串替换 console.clear(); var str = &quot;Tish is 2an 3apple&quot;; console.log(str.replace(&quot;Tish&quot;, &quot;This&quot;)); //不会改变原数据 console.log(str); console.log(str.replace(/\\d+/g, &quot;&quot;)); //返回空字符串 var html = `&lt;span&gt;hello&lt;/span&gt;&lt;div&gt; world&lt;/div&gt;`; console.log(html.replace(/&lt;[^&gt;]*([^&lt;&gt;]*)&lt;\\/[^&gt;]*&gt;/g, &quot;$1&quot;)); //p86 字符串隔离 console.clear(); var tags = &quot;heml, css, javascript&quot;; console.log(tags.split(&quot;,&quot;)); var str = &quot;This | is , an &amp; apple&quot;; console.log(str.split(/\\W+/g)); //p87 内置对象-number console.clear(); //转换字符串为整数 var strNum = &quot;15&quot;; var num = Number.parseInt(strNum); console.log(strNum); console.log(num); console.log(typeof num); var strNum = &quot;12.34&quot;; var num = parseFloat(strNum); console.log(num); console.log(typeof num); var strNum = &quot;abc&quot;; var num = parseInt(strNum); console.log(num); console.log(typeof num); console.log(isNaN(num)); console.log(isNaN(123)); var num = 12.33645; var numStr = num.toFixed(2); //保留两位小数 console.log(numStr); console.log(typeof numStr); console.log(Number.MAX_SAFE_INTEGER); //最大数 console.log(Number.POSITIVE_INFINITY); //正无限大 console.log(Number.NEGATIVE_INFINITY); //负无限大 //p88 Math console.clear(); console.log(Math.PI); //π console.log(Math.abs(-6)); //绝对值 console.log(Math.sin(Math.PI / 2)); //正弦 console.log(Math.floor(3.98)); //向下取整 console.log(Math.ceil(3.98)); //向上取整 console.log(Math.pow(10, 3)); //10的3次方 console.log(Math.trunc(2.645)); //返回整数，去掉小数点后的数 console.log(Math.random()); //随机返回一个0到1之间的随机数 //p89 Date 获取时间 console.clear(); var date = new Date(); console.log(date); console.log(date.getFullYear()); //获取年份 console.log(date.getMonth()); //获取月份，但这个月份是从0开始数的 console.log(date.getDay()); //获取周几 console.log(date.getDate()); //几号 console.log(date.getHours()); //几时 console.log(date.getMinutes()); //几分 console.log(date.getSeconds()); //几秒 console.log(date.getTime()); //1970年1月1日0点0分到现在过去u哦少毫秒 console.log(date.toLocaleDateString()); //获取本地时间表示方法 date.setFullYear(2022); //修改时间 console.log(date.toLocaleDateString()); date.setTime(1599210198629); //设置时间戳 console.log(date.toLocaleDateString()); //p90 内置对象-JSON对象介绍 console.clear(); var postJSON = `{ &quot;id&quot;:1, &quot;title&quot;:&quot;标题&quot;, &quot;comments&quot;:[ { &quot;userId&quot;:1, &quot;comment&quot;:&quot;评论1&quot; },{ &quot;userId&quot;:2, &quot;comment&quot;:&quot;评论2&quot; } ], &quot;published&quot;:true, &quot;author&quot;:null }`; console.log(JSON.parse(postJSON)); var person = { id: 1, name: &quot;佑砢&quot;, skills: [&quot;python&quot;, &quot;html5&quot;], }; console.log(person); console.log(JSON.stringify(person, null, 2)); var comments = `[ { &quot;userId&quot;:1, &quot;comment&quot;:&quot;评论1&quot; },{ &quot;userId&quot;:2, &quot;comment&quot;:&quot;评论2&quot; } ]`; console.log(JSON.parse(comments)); //p91 set(没有重复元素的集合) console.clear(); var set = new Set(); set.add(1); set.add(3); set.add(5); console.log(set); set.add(3); console.log(set); //重复值不会被添加 console.log(set.has(3)); //判断有无3 console.log(set.has(4)); //遍历 set.forEach((value) =&gt; { console.log(value); }); set.delete(3); //删除3 console.log(set); set.clear(); //清空 console.log(set); //添加内存对象，内容相同的对象不算重复 var obj1 = { id: 1 }; var obj2 = { id: 1 }; set.add(obj1); set.add(obj2); console.log(set); set.add(obj1); //名字相同的对象会被认为是重复，不会被再次添加 console.log(set); //p92 Map console.clear(); var map = new Map(); map.set(1, &quot;值1&quot;); map.set({ key: 2 }, &quot;值2&quot;); map.set(&quot;key 3&quot;, &quot;值3&quot;); console.log(map); console.log(map.get(1)); //按key搜索值 console.log(map.get(&quot;key 3&quot;)); console.log(map.get({ key: 2 })); //这样是访问不到的，需要按下面的创建方法才能访问到 var objKey = { key: 3 }; map.set(objKey, &quot;值3&quot;); console.log(map.get(objKey)); console.log(map.has(&quot;key 3&quot;)); //判断一个key是不是存在 //遍历 map.forEach((value, key) =&gt; { console.log(key, value); }); var iterator = map.entries(); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); //控制台done变成true表示迭代完了 for (let [key, value] of map) { console.log(key, value); } map.delete(1); //删除key为1的字段 console.log(map); //p93 异常-捕获异常 console.clear(); try { var emp = undefined; console.log(emp.name); } catch (err) { console.error(err); //也可以console.log(err),这里的err也可以自己定义，像是console.error(&quot;错误已处理&quot;) } finally { console.log(&quot;总会执行&quot;); //不管有没有异常finally都会执行 } //已经捕获的异常不会影响后续代码的执行 console.log(&quot;这行会执行&quot;); //p94 throw 抛出异常 console.clear(); function fetchData() { console.log(&quot;获取数据.......&quot;); throw &quot;404&quot;; } try { fetchData(); } catch (e) { if (e === &quot;404&quot;) { console.error(&quot;未查询到数据&quot;); } } //p95 error 对象 console.clear(); class ApiError extends Error { constructor(url, ...params) { super(...params); this.url = url; this.name = &quot;ApiError&quot;; } } function fetchData() { console.log(&quot;获取数据.......&quot;); throw new ApiError(&quot;/post&quot;, &quot;404&quot;); } try { fetchData(); } catch (e) { console.error(e); console.error(e.name); console.error(e.message); console.error(e.url); } //p96 捕获多个异常 console.clear(); function fetchData() { //console.log(a); console.log(&quot;获取数据.......&quot;); throw new ApiError(&quot;/post&quot;, &quot;404&quot;); } try { fetchData(); } catch (e) { if (e instanceof ReferenceError) { console.log(&quot;程序异常...&quot;); } else if (e instanceof ApiError) { console.log(&quot;API 异常&quot;); } } console.clear(); /* //p97 异步-setTimeout(把一个代码退后一步执行) console.clear(); //js特点是同步执行，会按照正常定义办法一部异步执行，遇到需要花费时间的代码会持续等待，异步就是把这些花费时间长的代码放到另一个地方执行,剩下的代码还会继续执行 console.log(&quot;第一行代码&quot;); setTimeout(() =&gt; { console.log(&quot;1秒后执行&quot;); }, 1000); //1000毫秒等于1秒 console.log(&quot;第二行代码&quot;); //会发现先打印了一二行代码再出现这个1秒后执行 var timer1 = setTimeout(() =&gt; { console.log(&quot;1秒后执行这个&quot;); }, 1000); setTimeout(() =&gt; { clearTimeout(timer1); console.log(&quot;中断了timer1的执行&quot;); }); //p98 异步-setInterval console.clear(); var interval = setInterval(() =&gt; { let date = new Date(); console.log(`${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`); }, 1000); setTimeout(() =&gt; { clearInterval(interval); console.log(&quot;中断了interval&quot;); }, 5000); */ /* //p99 异步-创建 promise console.clear(); var promise = new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(&quot;执行成功&quot;); }, 2000); }); //p100 promise 完成回调 promise.then((value) =&gt; console.log(value)); console.log(&quot;在promise前前执行这个&quot;); //p101 promise 异常捕获 var promise2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;执行失败&quot;); }, 2000); }); primise2.catch((error) =&gt; console.log(error)); console.log(&quot;在promise2前前执行这个&quot;); */ //p102 promise 链式调用 /* new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1); //reject(promise1异常) }, 1000); }) .then((value) =&gt; { console.log(value); //throw&quot;then1异常&quot; return value + 10; }) .then((value) =&gt; { console.log(value); return new Promise((resolve) =&gt; resolve(value + 20)); }) .then((value) =&gt; { console.log(value); }) .catch((error) =&gt; { console.log(error); }); */ /* //p103 多个promise同时执行 console.clear(); var p1 = new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(1); }, 1000); }); var p2 = new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(2); }, 2000); }); var p3 = new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(3); }, 500); }); Promise.all([p1, p2, p3]).then((values) =&gt; console.log(values)); //这里输入的顺序决定执行的舒顺序而不是上面规定的时间 */ /* //p104 异步-asyn&amp;await 用同步的代码模式来写异步的代码 console.clear(); async function async1() { setTimeout(() =&gt; { console.log(&quot;async 执行完毕&quot;); }, 1000); } async1(); console.log(async1()); //await async function async2() { let result2 = await async3(); let result3 = await async4(); try { let result4 = await async5(); } catch (e) { console.log(e); } console.log(result2); console.log(result3); //这里的顺序代表执行顺序 } async function async3() { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(10); }, 1000); }); } async function async4() { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(8); }, 500); }); } //弹出错误 async function async5() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;执行出错&quot;); }, 500); }); } async2(); */","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"-悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"js 基础语法第 2 期","slug":"js学习2","date":"2020-09-22T11:20:45.000Z","updated":"2020-09-22T11:53:48.529Z","comments":true,"path":"2020/09/22/js学习2/","link":"","permalink":"/2020/09/22/js学习2/","excerpt":"","text":"前言这部分的笔记从面对对象部分开始 下面是代码//p67 面对对象-定义class class Employee { constructor(name, position) { this.name = name; this.position = position; } } var emp = new Employee(&quot;佑砢&quot;, &quot;学生&quot;); console.log(emp); //p68 成员方法 console.clear(); class Employee2 { constructor(name, position) { this.name = name; this.position = position; } signIn() { console.log(this.name + &quot;打卡上班&quot;); } get info() { return this.name + &quot; &quot; + this.position; } set info(info) { let [name, position] = info.split(&quot; &quot;); this.name = name; this.position = position; } } var emp = new Employee2(&quot;佑砢&quot;, &quot;学生&quot;); emp.signIn(); console.log(emp.position); console.log(emp.info); //修改值 emp.info = &quot;李四 上班狗&quot;; console.log(emp.info); console.log(emp.name, emp.position); //p69 实现继承 console.clear(); //一个子类只能继承一个父类 class Manager extends Employee2 { constructor(name, position, dept) { super(name, position); //super代表父类 this.dept = dept; } signIn() { super.signIn(); console.log(&quot;额外信息：经理打卡&quot;); } } var manager = new Manager(&quot;王五&quot;, &quot;经理&quot;, &quot;技术部&quot;); console.log(manager); manager.signIn(); //不符合面对对象的定义 manager.dept = &quot;技术部&quot;; console.log(manager);","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"-悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"js 基础语法第 1 期","slug":"js学习1","date":"2020-09-22T11:03:16.000Z","updated":"2020-09-22T11:15:28.282Z","comments":true,"path":"2020/09/22/js学习1/","link":"","permalink":"/2020/09/22/js学习1/","excerpt":"","text":"前言该系列内的代码都能在浏览器的控制台进行输入检验，其中会有部分代码因为会影响到后续代码的执行而被注释，秩序手动复制粘贴在执行即可。 下面来看详细笔记（萌新刚学习可能会有部分错误，还希望有大佬能指正）//p1 console.log(&quot;hello word&quot;); // alert(&quot;hello word&quot;);就很蠢------ //p2变量 var name = &quot;佑砢君&quot;; name = &quot;佑砢君&quot;; /*不建议，可能后续忘了初始化报错,这种方法也能修改变量的值*/ //变量名区分大小写，驼峰命名法fontColor,或者下划线命名font_color,推荐驼峰，容易理解 console.log(name); var a = 5; var b = 6; console.log( a + b ); /*想要再次访问这个值就得保存a+b的结果到另一个变量上，因为这个值是一次性的*/ var c = a + b; console.log(c + 5); //p3常量 const FIVE_SECONDS = 5000; /*常量尽量全部大写下划线分隔不同单词便于理解*/ // FIVE_SECONDS = 6000; /*会报错，常量无法修改的*/----- // const button = new button(); /*常量定义按钮可以防止按钮被赋予另外的命令*/----- //p4基本数据类型 /*boolean 代表真假*/ var visible = true; var isEqual = false; console.log(visible); console.log(isEqual); /*number数字*/ var num = 100; //整数 var floatingNum = 13.34; //小数 var negative = -100; //负数 console.log(num); console.log(floatingNum); console.log(negative); /*string字符串*/ var str = &quot;Hello!&quot;; //单双引号都行 console.log(str); /*undefined未定义，变量还未定义*/ var notInitialized; //和var notInitialized=undefined一样 console.log(notInitialized); /*null空值*/ var emptyValue = null; console.log(emptyValue); /*object,对象array数组,function函数*/ //p5数据类型转换 console.log(typeof visible); //查看数据类型 console.log(typeof num); console.log(typeof floatingNum); //不管整数小数都是number类型 console.log(typeof str); console.log(typeof notInitialized); console.log(typeof emptyValue); //null是object类型 var age = 15; console.log(typeof age); age = &quot;15&quot;; console.log(typeof age); //number变为string,上面的typeof的输出还是number var result = num + str; //num=100是number类型，str=&quot;Hello!&quot;,是字符串 console.log(result); //会输出100Hello！ num被转换成string类型，+在string类型上是用作拼接 console.log(typeof result); //返回string类型 var strNum = &quot;123&quot;; console.log(parseInt(strNum) + num); //把string转换成整数parseInt(),小数用parseFloat() //p6注释 //单行注释，只能在单行 /* 多行 注释 */ /** * 对两个操作数进行加法运算 * @param {number} a 第一个操作数 * @param {number} b 第二个操作数 * @returns 返回两个操作数的和 */ function add(a, b) { return a + b; } add(1, 2); console.log(add(1, 2)); //p7赋值操作符 var x = 10; var y = x; //把x的值赋给y console.log(x, y); //逗号来分隔开不同的值，逗号可以写无数个，结果会以空格分割 //p8一元操作符 console.clear(); var negativeNum = -5; console.log(negativeNum); var strNum = +&quot;3&quot;; //+可以表示正数，或者把一个字符串变为number类型 console.log(strNum, typeof strNum); var num = 8; console.log(num++, num); //8++，先返回8再加1，++8先加1再返回 num = 8; //重新定义num=8，更好区分两个式子 console.log(++num, num); //--与++一样的运算规则 //p9算数操作符 console.clear(); console.log(&quot;1+5=&quot;, 1 + 5); //加法 console.log(&quot;5-1=&quot;, 5 - 1); //减法 console.log(&quot;3*9=&quot;, 3 * 9); //乘法 console.log(&quot;7/2=&quot;, 7 / 2); //除法 console.log(&quot;7%2=&quot;, 7 % 2); //取余数 console.log(&quot;4**2=&quot;, 4 ** 2); //指数操作 //p10比较操作符 console.clear(); console.log(&quot;1&gt;5&quot;, 1 &gt; 5); //返回的是boolean值 console.log(&quot;1&gt;=5&quot;, 1 &gt;= 5); console.log(&quot;1&gt;=1&quot;, 1 &gt;= 1); //==两个等于两边的值相同则为true，js会对两边的数值进行转换汤他们成为同一个类型再进行比较 console.log(&quot;5==5&quot;, 5 == 5); console.log(&#39;5==&quot;5&quot;&#39;, 5 == &quot;5&quot;); //===三个等于表示值和类型都要相同才返回true console.log(&quot;5===5&quot;, 5 === 5); console.log(&#39;5===&quot;5&quot;&#39;, 5 === &quot;5&quot;); console.log(&quot;undefined==null&quot;, undefined == null); console.log(&quot;undefined===null&quot;, undefined === null); //p11逻辑操作符 //&amp;&amp;与 同时真就是真，有一个假就是假 //||或 有一个真就都是真，两个假才是假 //！非 真就是假，假就是真 //js中代表false的有 false，0，“”，null，undefined console.clear(); console.log(&quot;true &amp;&amp; true&quot;, true &amp;&amp; true); console.log(&quot;true &amp;&amp; false&quot;, true &amp;&amp; false); console.log(&quot;true || false&quot;, true || false); console.log(&quot;!true&quot;, !true); //js特性 如果 与 判断第一个值为 true 就还会继续判断下一个值 console.log(&#39;true &amp;&amp; hello&quot;&#39;, true &amp;&amp; &quot;hello&quot;); //js特性 如果 或 判断第一个值为 false 就还会继续判断下一个值 console.log(&#39;false || &quot;hello&quot;&#39;, false || &quot;hello&quot;); var a = null; b = a || 5; console.log(b); //会输出5 //“短路”特性 当与的第一个操作数为false、非的第一个操作符为true就不会再继续判断下一个操作数 console.log(&#39;false &amp;&amp; &quot;not printed&quot;&#39;, false &amp;&amp; &quot;not printed&quot;); console.log(&#39;true || &quot;not printed&quot;&#39;, true || &quot;not printed&quot;); console.log(&#39;4 || &quot;not printed&quot;&#39;, 4 || &quot;not printed&quot;); console.log(&#39;4+1 || &quot;not printed&quot;&#39;, 4 + 1 || &quot;not printed&quot;); console.log(!4); //返回false，4代表一个真值 console.log(!!4); //返回true //p12 位运算符 console.clear(); //5的二进制101 //3的二进制011 //与的结果 001 也就是1 竖着计算的，与的运算规则，都是1就出1，有一个0就是0 console.log(&quot;5 &amp; 3&quot;, 5 &amp; 3); //5的二进制101 //3的二进制011 //与的结果 110 也就是7 竖着计算的，非的运算规则，有1就出1，都是0才出0 console.log(&quot;5 | 3&quot;, 5 | 3); //抑或运算 //5的二进制 101 //3的二进制 011 //相同出0不同出1 110 console.log(&quot;5^3&quot;, 5 ^ 3); //取反操作,基本上都是+1再加负号 console.log(&quot;~5&quot;, ~5); console.log(&quot;~3&quot;, ~3); //左移 //5的二进制原本是0101，左移一位就变成 1010 console.log(&quot;5&lt;&lt;1&quot;, 5 &lt;&lt; 1); //右移 //5的二进制原本是0101，右移一位就变成 010 console.log(&quot;5&gt;&gt;1&quot;, 5 &gt;&gt; 1); //无符号右移 //会标称负数，然后因为补码很多1就会变成一个很大的数 console.log(&quot;-5 &gt;&gt;&gt; 1&quot;, -5 &gt;&gt;&gt; 1); //p13 三目运算符 console.clear(); //如果判断条件为真，就执行？后面的代码，否则执行冒号后的代码 //可以在？：后面的代码再嵌套多层三目运算符，但是不利于阅读，最好不要这么干 var temperature = 10; console.log(temperature &gt; 15 ? &quot;出门&quot; : &quot;在家&quot;); //p14 代码块 console.clear(); //let定义的变量、const定义的常量都只能在语句块内部访问，var定义的变量可以在任何地方访问 { var name = &quot;蛤&quot;; console.log(name); let ages = 15; const year = 2020; console.log(ages); console.log(year); } console.log(name); //console.log(ages); //console.log(year); //p15 if else console.clear(); //var passcode = prompt(&quot;请输入暗号&quot;); //if (passcode === &quot;天王盖地虎&quot;) { // alert(&quot;登陆成功！&quot;); //} else { // alert(&quot;登陆失败！&quot;); //} //p16 if...else if...else console.clear(); //var role = prompt(&quot;请输入用户权限&quot;); //if (role === &quot;超级管理员&quot;) { // alert(&quot;跳转到超级管理员页面&quot;); //} else if (role === &quot;管理员&quot;) { // alert(&quot;跳转到管理员页面&quot;); //} else { // alert(&quot;跳转到用户页面&quot;); //} //p17 switch...case //var role = prompt(&quot;请输入用户权限&quot;); //switch (role) { // case &quot;超级管理员&quot;: // alert(&quot;超级管理员页面&quot;); // break;//这个break是让程序不再继续匹配剩下未匹配过的case // case &quot;管理员&quot;: // alert(&quot;管理员页面&quot;); // break; // case &quot;特殊用户&quot;: // alert(&quot;特殊用户页面&quot;); // break; // default: // alert(&quot;跳转到其他页面&quot;); //} //p18 while // var password = &quot;&quot;; // while (password !== &quot;123456&quot;) { // password = prompt(&quot;请输入密码&quot;); // } // alert(&quot;登陆成功&quot;); // var j = 0; // while (j &lt; 10) { // console.log(j); // j++; // } //p19 do...while //无论while的结果是false还是true，do的语句块都会执行一次 // var haha = 5; // do { // console.log(haha++); // } while (haha &gt; 5 &amp;&amp; haha &lt;= 10); //p20 for // for (let i = 0; i &lt; 10; i++) { // console.log(i); // } //死循环 // for(;;){ // console.log(&quot;true&quot;) // } //p21 break/continue //break直接跳出循环，continue是跳过当前这次循环 console.clear(); for (let i = 0; i &lt; 10; i++) { if (i === 6) { break; } console.log(i); } console.clear(); for (let i = 0; i &lt; 10; i++) { if (i === 6) { continue; } console.log(i); } //p22 声明函数 console.clear(); function putInRefrigerator() { console.log(&quot;打开冰箱门&quot;); console.log(&quot;把大象放进去&quot;); console.log(&quot;关上冰箱门&quot;); } function putAnythingInRefrigerator(something) { console.log(&quot;打开冰箱门&quot;); console.log(&quot;把&quot; + something + &quot;放进去&quot;); console.log(&quot;关上冰箱门&quot;); } function add(a, b) { return a + b; } function testNum(num) { if (num &lt; 0) return; //if 语句只有一行就可以直接写不换行 return num &gt; 10; } //p23 调用函数 putInRefrigerator(); putAnythingInRefrigerator(&quot;兔子&quot;); add(5, 4); //这样是没返回的，因为函数里面没有console.log console.log(add(5, 4)); var result = add(1, 2); //把函数的值赋给一个变量 console.log(result); console.log(add(result, 5)); console.log(testNum(15)); //p24 函数表达式 console.clear(); console.log(add); //这样就是直接看函数的内容 var plus = add; //函数能够这样传递 var res = plus(5, 6); console.log(res); //匿名函数(multip可以直接不写) var multiply = function multip(a, b) { return a * b; }; console.log(multiply(6, 2)); //p25 变量和函数提升Hoisting console.clear(); //正常来说，一定要先定义变量才能访问，例如 xx = 6; console.log(xx); var x = 5; //这样会输出xx为6而不是5 //但函数是全局的，所以我们可以将函数放在底部代码，方便观察代码逻辑 //例如 console.log(divide(8, 4)); function divide(a, b) { return a / b; } //p26 默认参数 console.clear(); function greetings(name = &quot;佑砢君&quot;) { console.log(&quot;你好，&quot; + name); } greetings(); greetings(&quot;李明&quot;); //默认值可以覆盖 //如果函数有多个参数，但只有第一个有默认值，想雅要给第二个参数传值，第一个值还是想用默认值，可以传undefined(不能用null) function greetingWithWeather(name = &quot;佑砢君&quot;, weather) { console.log(&quot;你好，&quot; + name + &quot;，今天是：&quot; + weather); } greetingWithWeather(undefined, &quot;小雨&quot;); //p27 递归 console.clear(); //计算1到n之间的和 function sum(n) { if (n === 1) { return 1; } return n + sum(n - 1); } console.log(sum(3)); //斐波纳契数列 //1 1 2 3 5 8 13 function fib(num) { if (num &lt;= 1) { return 1; } return fib(num - 1) + fib(num - 2); } console.log(fib(5)); //p28 函数-arguments //当用户输入多个值我们只输出指定数量的值 console.clear(); function log() { console.log(arguments[0]); //只输出第一个值 } log(&quot;abc&quot;, &quot;bcd&quot;); //bcd会被忽略 //假如要全部输出用户输入的内容 function logAll() { for (let i = 0; i &lt; arguments.length; i++) { console.log(arguments[i]); } } logAll(&quot;abc&quot;, &quot;bcd&quot;); //p29 作用域 var x = 5; //全局作用域变量 //局部作用域变量指的是定义在函数内部的变量，只能在函数内部使用 function adds(a) { var z = 10; console.log(&quot;z=&quot; + z); return a + x; //可以访问全局作用域变量 } console.log(adds(8)); //console.log(z); //不能再函数外部访问函数内定义的变量 //如果局部作用域变量的名字和全局作用域变量名字相同，那么局部的会覆盖掉全局的 var num = 100; function multiplys(num) { return num * 10; } console.log(multiplys(4)); //会返回4*10而不是100*10的结果 //p30 var/let console.clear(); var z = 6; if (z &gt; 2) { console.log(z); var innerZ = 17; let innerW = 16; } console.log(innerZ); //console.log(innerW); for (var i = 0; i &lt; 10; i++) { console.log(i); let innerI = 33; } console.log(i); //console.log(innerI); //p31 箭头函数(可以简化函数定义) console.clear(); var greeting = () =&gt; { //没有参数那么这个括号不能省略 console.log(&quot;hello&quot;); }; greeting(); var greetHello = (name, timeing) =&gt; { console.log(&quot;hello&quot; + name + &quot;今天是&quot; + timeing); }; greetHello(&quot;佑砢&quot;, &quot;周五&quot;); //如果箭头函数有返回值并且只有一行代码，那么可以省略大括号和return var increment = (x) =&gt; x + 1; console.log(increment(6)); //p32闭包 console.clear(); function squareSum(a, b) { function square(x) { return x * x; } return square(a) + square(b); } console.log(squareSum(2, 3)); function person() { let name = &quot;佑砢&quot;; function getName() { return name; } return getName; } var getName = person(); console.log(getName); console.log(getName()); //这样就相当于给name设置了只读属性 //p33柯里化 console.clear(); //正常写法 function addThreeNums(a, b, c) { return a + b + c; } console.log(addThreeNums(1, 2, 3)); //柯里化写法 function addThreeNumsCurry(a) { return function (b) { return function (c) { return a + b + c; }; }; } console.log(addThreeNumsCurry(1)(2)(3)); var fiexdTwo = addThreeNumsCurry(1)(2); console.log(fiexdTwo(4)); console.log(fiexdTwo(5)); console.log(fiexdTwo(6)); //p34自执行函数 console.clear(); var num1 = 20; (function () { var num1 = 10; console.log(num1); })(); //加()是让他自执行 console.log(num1); //可以发现先输出自执行函数的num1再输出外部定义的num1，并且自执行函数内的参数不会与外部变量冲突 //p35回调用函数 console.clear(); function request(cb) { console.log(&quot;请求数据&quot;); cb(&quot;success&quot;); console.log(&quot;请求结束&quot;); } function callback(result) { console.log(&quot;执行回调&quot;); console.log(&quot;执行结果是： &quot; + result); } request(callback); //p36创建数组 console.clear(); var arr1 = [1, 2, 3]; console.log(arr1); var arr2 = new Array(4, 5, 6); console.log(arr2); var arr3 = Array(7, 8, 9); console.log(arr3); var arr4 = Array.of(10, 11, 12); console.log(arr4); var arrSingle = Array(6); console.log(arrSingle); var arrSingle2 = new Array(7); console.log(arrSingle2); var arrSingle3 = Array.of(4); //创建单字符数组 console.log(arrSingle3); var arrSingle4 = [9]; //创建单字符数组 console.log(arrSingle4); //p37访问数组 console.clear(); var arr = [1, 2, 3]; console.log(arr.length); console.log(arr[0]); console.log(arr[1]); console.log(arr[2]); //访问超出长度的数组会返回undefined console.log(arr[4]); //p38添加元素 console.clear(); //可以指定再某个位置添加，如果该位置已经有值则覆盖，新位置大于数组长度则会自动增加长度并用空的元素补充空位 var arr = [1, 2, 3]; arr[0] = 4; console.log(arr); arr[5] = 5; console.log(arr); //p39删除元素 console.clear(); var arr = [1, 2, 3]; arr.length = 2; console.log(arr); //清空 arr.length = 0; console.log(arr); //删除指定元素 var arr = [1, 2, 3, 4, 5, 6]; arr.splice(2, 1); //删除的索引和删除的数量 console.log(arr); arr.splice(1, 2, 3, 7, 8); //删除索引为1开始的两个值并替换成3，7，8 console.log(arr); //给数组任意位置添加新值 arr.splice(1, 0, 9, 10); //默认会添加到指定索引的前一位 console.log(arr); //p40数组遍历 console.clear(); var arr = [1, 3, 5, 7, 9]; for (let i = 0; i &lt; arr.length; i++) { console.log(arr[i]); } console.log(&quot;for....of&quot;); for (let ele of arr) { console.log(ele); } arr.forEach((ele, index, self) =&gt; { console.log(ele, index, self); }); //p41栈模式（后进先出） //进 console.clear(); var stack = [1, 2, 3]; stack.push(4); console.log(stack); //进 stack.push(5, 6, 7); console.log(stack); //出 var last = stack.pop(); console.log(last); console.log(stack); //直接访问你最后一个元素 console.log(stack[stack.length - 1]); //p42队列模式(先进先出) console.clear(); var queue = [1, 2, 3]; queue.push(4, 5, 6); console.log(queue); //出队 var first = queue.shift(); console.log(first); console.log(queue); //从数组头部添加元素 queue.unshift(10, 11, 12); console.log(queue); //p43反转数组 console.clear(); var arr = [1, 2, 3]; console.log(arr.reverse()); //会改变原数组 console.log(arr); //反转字符串 console.log(&quot;hello&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;)); //p44数组排序 console.clear(); var arr = [1, 5, 3, 2, 4]; arr.sort(); //会改变原数组 console.log(arr); //降序排列 arr.sort((a, b) =&gt; { if (a &gt; b) { return -1; } else if (a &lt; b) { return 1; } else { return 0; } }); //简写为arr.sort((a, b) =&gt;b-a) console.log(arr); //p45数组连接 console.clear(); var arr1 = [1, 2, 3]; var arr2 = [4, 5, 6]; console.log(arr1.concat(arr2)); //p46数组裁切 console.clear(); var arr = [1, 2, 3, 4, 5, 6]; console.log(arr.slice(1)); console.log(arr.slice(1, 3)); //开始，结束；结束索引不会包含在结果里 console.log(arr.slice(1, -1)); //p47 数组map console.clear(); var arr = [1, 2, 3, 4]; var mappedArr = arr.map((ele) =&gt; ele * 2); console.log(mappedArr); //原数组不会变化 console.log(arr); //p48 数组reduce console.clear(); var arr = [1, 2, 3, 4]; //previous表示上一次计算结果，current表示当前遍历元素，最后的规定了上一个计算结果，可以没有 var result = arr.reduce((previous, current) =&gt; previous + current, 0); console.log(result); var result2 = arr.reduce((first, second) =&gt; first + second); console.log(result2); //p49 数组过滤(筛选) console.clear(); var arr = [1, 2, 3, 4, 5, 6]; var filteredArr = arr.filter((item) =&gt; item &gt; 4); console.log(filteredArr); //p50 数组测试 console.clear(); var arr = [1, 2, 3, 4, 5, 6]; var result = arr.every((item) =&gt; item &gt; 0); console.log(result); //判断是否有一个元素大于5 var resultSome = arr.some((item) =&gt; item &gt; 5); console.log(resultSome); //p51 解构操作符destructuring console.clear(); var arr = [1, 2, 3]; var [a, b, c] = arr; console.log(a, b, c); var [d, e] = arr; console.log(d, e); var [, f] = arr; console.log(f); function multipleReturns() { let name = &quot;佑砢君&quot;; let position = &quot;前端工程师&quot;; return [name, position]; } var [myName, myPosition] = multipleReturns(); console.log(myName, myPosition); //p52 数组rest操作符 console.clear(); var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var [a, b, ...rest] = arr; //rest无特别意义，可以换别的 console.log(a, b, rest); var [a, , b, ...rest] = arr; console.log(a, b, rest); function variousArgs(...args) { console.log(args); } variousArgs(1, 2, 3); //p53 多维数组 console.clear(); var arr = []; for (let i = 0; i &lt; 5; i++) { arr[i] = []; for (let j = 0; j &lt; 4; j++) { arr[i][j] = i + j; } } console.log(arr); //p54 创建对象 console.clear(); var employee = { name: &quot;张三&quot;, age: 20, position: &quot;前端工程师&quot;, signIn: function () { console.log(&quot;张三打卡&quot;); }, }; var employee2 = new Object(); employee2.name = &quot;李四&quot;; employee2.signIn = function () { console.log(&quot;李四打卡&quot;); }; var employee3 = { name: &quot;王五&quot;, &quot;birth-day&quot;: &quot;199-10-1&quot;, //key中有中划线类似的字符就要用引号，同时也只能有[]来访问这个属性 }; console.log(employee3[&quot;birth-day&quot;]); //p55 对象属性 //访问对象属性 console.clear(); console.log(employee.name); console.log(employee[&quot;name&quot;]); //更新对象属性 employee.name = &quot;张五&quot;; console.log(employee.name); employee[&quot;name&quot;] = &quot;张六&quot;; console.log(employee[&quot;name&quot;]); //访问不存在的属性会返回undefined console.log(employee2.age); employee2[&quot;age&quot;] = 22; console.log(employee2[&quot;age&quot;]); //p56 省略key console.clear(); var name = &quot;李四&quot;; var employee4 = { name, //原句是name:name,这里类似的可以省略key signIn() { console.log(&quot;李四打卡&quot;); }, }; console.log(employee4.name); console.log(employee4.signIn()); //p57 遍历对象 console.clear(); console.log(Object.keys(employee)); for (key in employee) { console.log(key); } //p56 删除对象属性 console.clear(); delete employee.name; console.log(employee); console.log(Object.keys(employee)); //p57 构造函数(也是创建对象的一种方法) console.clear(); function Employee(name, position) { this.name = name; this.position = position; } var emp1 = new Employee(&quot;佑砢&quot;, &quot;学生&quot;); console.log(emp1); var emp2 = new Employee(&quot;张三&quot;, &quot;后端工程师&quot;); console.log(emp2); //p58 this console.clear(); var emp3 = { name: &quot;李六&quot;, position: &quot;后端实习生&quot;, signIn() { console.log(this.name + &quot;上班打卡&quot;); }, }; emp3.signIn(); emp3.goToWork = function () { console.log(this.name + &quot;去上班&quot;); }; emp3.goToWork(); //p59 对象getter和setter console.clear(); var person = { firstName: &quot;三&quot;, lastName: &quot;张&quot;, get fullName() { return this.lastName + this.firstName; }, set fullName(fullName) { //set 只能接受一个参数，我们用，为界限切割姓和名 let [lastName, firstName] = fullName.split(&quot;,&quot;); this.lastName = lastName; this.firstName = firstName; }, }; console.log(person.fullName); person.fullName = &quot;李,四&quot;; console.log(person.fullName); console.log(person.firstName, person.lastName); function Employee2(name, position) { this.name = name; this.position = position; } var emp5 = new Employee2(&quot;赵六&quot;, &quot;前端工程师&quot;); Object.defineProperty(emp5, &quot;info&quot;, { get: function () { return this.name + &quot; &quot; + this.position; }, set function(info) { let [name, position] = info.split(&quot;,&quot;); this.name = name; this.position = position; }, }); console.log(emp5.info); emp5.info = &quot;赵七，后端工程师&quot;; console.log(emp5.name); console.log(emp5.position); //p60 原型 console.clear(); function Employee(name, position) { this.name = name; this.position = position; this.signIn = function () { console.log(this.name + &quot;打卡&quot;); }; } var emp1 = new Employee(&quot;张三&quot;, &quot;前端工程师&quot;); var emp2 = new Employee(&quot;李四&quot;, &quot;后端工程师&quot;); console.log(emp1); console.log(emp2); //给原型添加key console.log(Employee.prototype); Employee.prototype.age = 20; console.log(emp1.age); console.log(emp2.age); //给原型添加方法 Employee.prototype.printInfo = function () { console.log(this.name, this.age, this.position); }; emp1.printInfo(); emp2.printInfo(); console.log(emp1.__proto__); console.log(Employee.prototype); console.log(emp1.__proto__ === Employee.prototype); console.log(Object.getPrototypeOf(emp2)); //p61 Object.create() console.clear(); console.log(emp1); for (key in emp1) { console.log(key); } var manager = Object.create(emp1); console.log(manager); for (key in manager) { console.log(key); } console.log(manager.name); manager.name = &quot;李四&quot;; manager.position = &quot;经理&quot;; console.log(manager); manager.signIn(); console.log(Object.getOwnPropertyNames(manager)); //p62 原型链 console.clear(); var protoOfManager = Object.getPrototypeOf(manager); console.log(protoOfManager); var protoOfEmp1 = Object.getPrototypeOf(protoOfManager); console.log(protoOfEmp1); var protoOfEmp = Object.getPrototypeOf(protoOfEmp1); console.log(protoOfEmp); var protoOfObj = Object.getPrototypeOf(protoOfEmp); console.log(protoOfObj); console.log(Object.getPrototypeOf(Object.prototype)); //p63 修改原型指向 console.clear(); function Manager() {} Manager.prototype.department = &quot;技术部&quot;; Object.setPrototypeOf(manager, Manager.prototype); console.log(manager.department); console.log(Object.getPrototypeOf(manager)); //console.log(manager.signIn()); for (key in manager) { console.log(key); } //p64 spread操作符 console.clear(); var post = { id: 1, title: &quot;标题1&quot;, content: &quot;这是内容&quot;, }; console.log(post); var postClone = { ...post }; console.log(postClone); console.log(post === postClone); var post2 = { ...post, author: &quot;佑砢君&quot; }; console.log(post2); var arr = [1, 2, 3]; var arrClone = [...arr]; console.log(arrClone); var arr2 = [...arr, 4, 5, 6]; console.log(arr2); function savePost(id, title, content) { console.log(&quot;保存了文章：&quot;, id, title, content); } savePost(...[2, &quot;标题&quot;, &quot;内容&quot;]); //p65 对象destructuring&amp;rest console.clear(); var post = { id: 1, title: &quot;标题1&quot;, content: &quot;这是内容&quot;, }; var { id, title } = post; //变量名要和对象的属性名保持一致 console.log(id, title); //如果变量名要用别名则要用冒号 var { id, title: headline } = post; console.log(id, headline); //也可以定义默认值防止对象中没有这个属性 var { id, title, comments = &quot;没有评论&quot; } = post; console.log(comments); //null不会被赋默认值因为null是个值 //数组也可以有默认值 var [a, b = 2] = [1]; console.log(a, b); var post2 = { id: 2, title: &quot;标题2&quot;, content: &quot;这是内容&quot;, comments: [ { userId: 1, comment: &quot;评论1&quot;, }, { userId: 2, comment: &quot;评论2&quot;, }, { userId: 3, comment: &quot;评论3&quot;, }, ], }; var { comments: [, { comment }], //相当于评论1取空，只要评论2 } = post2; console.log(comment); //获取动态的值 function getId(idKey, obj) { let { [idKey]: id } = obj; return id; } console.log(getId(&quot;userId&quot;, { userId: 3 })); //rest var { comments, ...rest } = post2; console.log(rest); function savePostObj({ id, title, content, ...rest }) { console.log(&quot;保存了文章：&quot;, id, title, content); console.log(rest); } savePostObj({ id: 4, title: &quot;标题4&quot;, content: &quot;内容4&quot;, author: &quot;佑砢&quot; }); //p66 值传递和引用传递 console.clear(); //数组 function byReference(arr) { arr[0] = 5; } var array = [1, 2, 3]; byReference(array); console.log(array); //对象 function byReferenceObj(obj) { obj.title = &quot;标题标题&quot;; } var post = { id: 1, title: &quot;标题&quot; }; byReferenceObj(post); console.log(post); //string function byReferenceStr(str) { str = &quot;abc&quot;; } var testStr = &quot;test&quot;; byReferenceStr(testStr); console.log(testStr); //值传递 function byValue(num) { num = 10; console.log(num); } var testNums = 1; byValue(testNums); console.log(testNums); //原值没有被修改 //p67 call,apply,bind console.clear(); var emp = { id: 1, name: &quot;佑砢&quot;, }; function printInfo(dep1, dep2, dep3) { console.log(&quot;员工姓名&quot; + this.name, dep1, dep2, dep3); } printInfo.call(emp, &quot;技术部&quot;, &quot;IT部&quot;, &quot;总裁办公室&quot;); printInfo.apply(emp, [&quot;技术部&quot;, &quot;IT部&quot;, &quot;总裁办公室&quot;]); var empPrintInfo = printInfo.bind(emp, &quot;技术部&quot;, &quot;IT部&quot;, &quot;总裁办公室&quot;); empPrintInfo();","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"-悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"公司前端实战","slug":"交作业啦","date":"2020-05-03T11:24:55.000Z","updated":"2020-05-03T12:38:50.077Z","comments":true,"path":"2020/05/03/交作业啦/","link":"","permalink":"/2020/05/03/交作业啦/","excerpt":"","text":"前言这次的网站在峰华老师的指导下完成，虽然还有细节没有完善还请假装没看见 点击这里跳转 箭头 →我叫这里","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"-悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"jsdelivr 免费 cdn 加速服务","slug":"jsdelivr免费cdn加速服务","date":"2020-04-11T11:48:40.000Z","updated":"2020-04-11T12:13:14.332Z","comments":true,"path":"2020/04/11/jsdelivr免费cdn加速服务/","link":"","permalink":"/2020/04/11/jsdelivr免费cdn加速服务/","excerpt":"","text":"每次访问不了 github 上的资源的时候真的是头大在技术群里询问了很久才发现大多数人都用过 jsdelivr 的免费 cdn 加速服务访问 github 上的资源（只有我一个啥都不懂的萌新还在死板的写链接然后经常挂掉 😭） 进入正题使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 下面举个例子https://cdn.jsdelivr.net/gh/nekochram/nekochram.github.io/images/blogphotos/jsdelivr免费cdn加速服务/bg.jpg这里 nekochram 是我的 github 用户名，而 nekochram.github.io 就是我的仓库名了，版本号其实可以不用加，后面的就是某个具体文件的路径啦。如果你不知道集体的文件路径，你只需要进入 github 然后找到这个文件，再点击右上角的 copy path 就行辣 😄","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"-悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实用网站推荐","slug":"实用网站推荐","date":"2020-03-31T14:07:21.000Z","updated":"2020-04-06T12:29:22.520Z","comments":true,"path":"2020/03/31/实用网站推荐/","link":"","permalink":"/2020/03/31/实用网站推荐/","excerpt":"","text":"前言以前在学习剪辑视频的时候发现的一些偷懒、娱乐资源工具网站，现在分享出来希望能够对你有所帮助！ 新媒体导航https://www.kaolamedia.com/这个网站拥有很全的网址，而且分类很细。 在线的小工具对各类创作者都极有用！ 老照片上色https://colourise.sg/省去打开 ps 的时间，在线即可完成老照片上色，简单快速。 太鼓达人https://taiko.bui.pm/这个网页实在太 🐮 了，游戏很流畅，就是判定有点严格，没事可以玩一玩。要手的算了吧 词云https://www.weiciyun.com/在线生成文字云图，跟着引导走就完事了。 封面下载https://cover.olook.me/常常看到一些视频的封面很赞可是又找不到办法下载？这个能为你解忧！ 表情包制作https://sorry.xuty.tk/sorry/什么？和沙雕群友斗图斗不过？咱怎么能受这个气,我@#$#@^#$^ 商品精选http://www.smzdm.com/剁手剁手，我真的没钱了 捏人http://www.dreamself.me/clothes.php?action=view&amp;id=0&amp;c=1不说了我这就去玩这个老婆生成器","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[{"name":"-悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]}]}